<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>js的内存空间 · 长剑腥腥挂壁</title><meta name="description" content="JavaScript中的变量分为基本类型和引用类型基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象
栈栈是限定仅在表头进行插入和删除操作的线性表。特点是后进先出允许进行插入和删除的一端成为栈顶，另一端称为栈底插入称为进栈（PUSH），删除称为退栈（POP）
堆堆是一种"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>js的内存空间</a></h3></div><div class="post-content"><p>JavaScript中的变量分为基本类型和引用类型<br>基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是限定仅在表头进行插入和删除操作的线性表。特点是<code>后进先出</code><br>允许进行插入和删除的一端成为栈顶，另一端称为栈底<br>插入称为进栈（PUSH），删除称为退栈（POP）<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550656615569-c45cd741-1235-48b3-9617-5aeb16b1d651.jpeg#align=left&amp;display=inline&amp;height=348&amp;linkTarget=_blank&amp;name=IMG_4953.JPG&amp;originHeight=1000&amp;originWidth=750&amp;size=210000&amp;width=261" alt="IMG_4953.JPG"></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象<br><img src="https://cdn.nlark.com/yuque/0/2019/png/115449/1550657572573-8227ea4c-bbd5-4403-a304-27d0ca822bb6.png#align=left&amp;display=inline&amp;height=216&amp;linkTarget=_blank&amp;name=20190220181242.png&amp;originHeight=418&amp;originWidth=963&amp;size=91589&amp;width=497" alt="20190220181242.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550658085149-5f25c1a3-0017-4230-9fb1-62f8845630f6.jpeg#align=left&amp;display=inline&amp;height=88&amp;linkTarget=_blank&amp;name=DINGTALK_IM_3057285245.JPG&amp;originHeight=993&amp;originWidth=3787&amp;size=252707&amp;width=335" alt="DINGTALK_IM_3057285245.JPG"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：<code>先进先出</code>。从一端放入元素的操作称为入队，取出元素为出队<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550657477420-ab5e365f-8c16-4796-b651-293e61187e4b.jpeg#align=left&amp;display=inline&amp;height=106&amp;linkTarget=_blank&amp;name=DINGTALK_IM_44170428.JPG&amp;originHeight=888&amp;originWidth=4021&amp;size=203294&amp;width=480" alt="DINGTALK_IM_44170428.JPG"></p>
<h3 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h3><p><code>基本类型</code>有Undefined、Null、Boolean、Number 、String和Symbol。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的</p>
<p><code>引用类型</code>保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问<br><img src="https://cdn.nlark.com/yuque/0/2019/png/115449/1550714834962-aade7228-85db-47ac-a2d4-63112d10b2aa.png#align=left&amp;display=inline&amp;height=259&amp;linkTarget=_blank&amp;name=20190221100701.png&amp;originHeight=373&amp;originWidth=681&amp;size=84578&amp;width=473" alt="20190221100701.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123;<span class="attr">m</span>: <span class="number">20</span>&#125;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<h3 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>
<p>var a = 1;</p>
<table>
<thead>
<tr>
<th>a</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>var b = a;</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>b = 2;</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>b值被修改，并不会影响到a值，a为1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'Lucy'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.name = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>
<p>a,b都是引用类型，栈内存中存放地址指向堆内存的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量的对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改<code>b.name</code>的值后，<code>a.name</code>的值也会被修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'Lucy'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>
<p>此时a,b的地址指针都指向<code>{ name: &#39;Lucy&#39;}</code>这个对象，a被赋值修改为一个基本类型null，但不会影响到堆内存中的对象，所以b的值不会受影响</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">// ???</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure>
<p>a,b都指向同一个对象<code>{n: 1}</code></p>
<p>不好理解的就是这句<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>啥意思，js赋值运算顺序是从右向左，但是<code>.</code>是优先级最高的运算符<br>所以先运算<code>a.x</code><br>拆解之后的执行步骤<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x</span><br><span class="line">a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line">a.x = a;</span><br></pre></td></tr></table></figure></p>
<p>现在我们一步一步来分析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550718849318-98478ce7-357e-43ea-b1bf-4d3aab4b62a2.jpeg#align=left&amp;display=inline&amp;height=275&amp;linkTarget=_blank&amp;name=DINGTALK_IM_3096870398.JPG&amp;originHeight=2023&amp;originWidth=3127&amp;size=315206&amp;width=425" alt="DINGTALK_IM_3096870398.JPG"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550719017280-86f24d62-9d8f-4e5b-9021-c8b717d6e175.jpeg#align=left&amp;display=inline&amp;height=248&amp;linkTarget=_blank&amp;name=DINGTALK_IM_1976603065.JPG&amp;originHeight=1343&amp;originWidth=2434&amp;size=207798&amp;width=450" alt="DINGTALK_IM_1976603065.JPG"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550719304042-87daad72-30c9-47ba-b0a4-e409f5c33a7d.jpeg#align=left&amp;display=inline&amp;height=274&amp;linkTarget=_blank&amp;name=DINGTALK_IM_711758233.JPG&amp;originHeight=2010&amp;originWidth=3481&amp;size=422373&amp;width=474" alt="DINGTALK_IM_711758233.JPG"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x = a;</span><br></pre></td></tr></table></figure>
<p>由于一开始js已经先计算了a.x，便已经解析了这个a.x是<code>{n: 1,x: undefined}</code>的x，所以在同一条公式的情况下再回来给a.x赋值，也不会说重新解析这个a.x为<code>{n: 2}</code>的x<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1550719619319-d98010bb-f604-4741-998e-1de17a895fb5.jpeg#align=left&amp;display=inline&amp;height=280&amp;linkTarget=_blank&amp;name=DINGTALK_IM_1641065839.JPG&amp;originHeight=2051&amp;originWidth=3169&amp;size=379034&amp;width=432" alt="DINGTALK_IM_1641065839.JPG"></p>
<p>所以<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">// &#123;n:2&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="const变量申明"><a href="#const变量申明" class="headerlink" title="const变量申明"></a>const变量申明</h3><p>const的作用是声明变量为常量，实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 报错 Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></p>
<p>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.name = <span class="string">'Lucy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123;name: 'Lucy'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">b.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-02-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/js/" title="js">js </a><a class="tag" href="/tags/内存空间/" title="内存空间">内存空间 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/02/22/前端路由/" title="前端路由">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/02/20/Python—编写webAPI/" title="Python—编写web API">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>