<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>柯里化与反柯里化 · 长剑腥腥挂壁</title><meta name="description" content="柯里化柯里化又称部分求值，就是不会立刻求值，而是到了需要的时候再去求值，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数
求和函数123456789101112131415161"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>柯里化与反柯里化</a></h3></div><div class="post-content"><p><a name="c28ab5f2"></a></p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化又称部分求值，就是不会立刻求值，而是到了需要的时候再去求值，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果<br>把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数<br><a name="55b79f93"></a></p>
<h4 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// apply的第一个参数是用来替换的操作对象，第二个参数是要变成push参数的数组</span></span><br><span class="line">        [].push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sum = adder();</span><br><span class="line"><span class="comment">// 一次调用可输入一个或者多个参数，并且支持链式调用 </span></span><br><span class="line"><span class="keyword">var</span> a = sum(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>)()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><code>adder</code>是柯里化了的函数，它返回一个新的函数，新的函数可分批次接受新的参数，延迟到最后一次计算<br><a name="90743082"></a></p>
<h4 id="通用的柯里化函数"><a href="#通用的柯里化函数" class="headerlink" title="通用的柯里化函数"></a>通用的柯里化函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, c; c = <span class="built_in">arguments</span>[i++];) &#123;</span><br><span class="line">        total += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sum = currying(multi);</span><br><span class="line">  </span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line">sum(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><a name="7e703669"></a></p>
<h3 id="反柯里化"><a href="#反柯里化" class="headerlink" title="反柯里化"></a>反柯里化</h3><p>反柯里化的作用在与扩大函数的适用性，使本来作为特定对象所拥有的功能的函数可以被任意对象所用<br>有以下轻提示类。现在想要单独使用其<code>show</code>方法，输出新对象<code>obj</code>中的内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轻提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toast</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prompt = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">Toast.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Toast,</span><br><span class="line">  // 输出提示</span><br><span class="line">  show: function()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.prompt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prompt: <span class="string">'新对象'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unCurrying</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> that = args.shift(); <span class="comment">// obj</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(that, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objShow = unCurrying(Toast.prototype.show);</span><br><span class="line">objShow(obj); <span class="comment">// 新对象</span></span><br></pre></td></tr></table></figure></p>
<p><code>Toast.prototype.show</code>方法，本来是<code>Toast</code>类的私有方法。跟新对象<code>obj</code>没有任何关系，经过反柯里化后，却可以为<code>obj</code>对象所用 <br>内部将<code>Toast.prototype.show</code>的上下文重新定义为<code>obj</code>。也就是用<code>apply</code>改变了<code>this</code>指向。 <br>而实现这一步骤的过程，就需要增加反柯里化后的<code>objShow</code>方法参数<br><a name="a3d74e7c"></a></p>
<h4 id="另一种反柯里化的实现"><a href="#另一种反柯里化的实现" class="headerlink" title="另一种反柯里化的实现"></a>另一种反柯里化的实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轻提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toast</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.prompt = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">Toast.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Toast,</span><br><span class="line">  // 输出提示</span><br><span class="line">  show: function()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.prompt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    prompt: <span class="string">'新对象'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> objShow = Toast.prototype.show.unCurrying();</span><br><span class="line">objShow(obj);</span><br></pre></td></tr></table></figure>
<p>理解 <code>Function.prototype.call.apply(self, arguments)</code><br>可以分拆为两步：<br>1） <strong><code>Function.prototype.call.apply(...)</code>的解析</strong><br>可以看成是<code>callFunction.apply(...)</code>。这样就清晰很多 <br><code>callFunction</code>的<code>this</code>指针，被<code>apply</code>修改为<code>self</code>。 <br>然后执行<code>callFunction</code> -&gt; <code>callFunction(arguments)</code><br>2） <strong><code>callFunction(arguments)</code>的解析</strong><br><code>call</code>方法，第一个参数，是用来指定<code>this</code>的。所以<code>callFunction(arguments)</code> -&gt; <code>callFunction(arguments[0], arguments[1-n])</code>。 <br>由此可以得出，反柯里化后，第一个参数，是用来指定<code>this</code>指向的。<br>3）<strong>为什么要用apply(self, arguments)</strong> <br>如果使用<code>apply(null, arguments)</code>，因为<code>null</code>对象没有<code>call</code>方法，会报错</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-03-20</span><i class="fa fa-tag"></i><a class="tag" href="/tags/柯里化/" title="柯里化">柯里化 </a><a class="tag" href="/tags/反柯里化/" title="反柯里化">反柯里化 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/03/21/TypeScript—高级类型/" title="TypeScript—高级类型">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/03/19/滚动加载/" title="滚动加载">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>