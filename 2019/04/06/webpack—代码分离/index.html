<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>webpack—代码分离 · 长剑腥腥挂壁</title><meta name="description" content="代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间常用的代码分离方法有三种：

入口起点：使用 entry 配置手动"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>webpack—代码分离</a></h3></div><div class="post-content"><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间<br>常用的代码分离方法有三种：</p>
<ul>
<li>入口起点：使用 <a href="https://webpack.docschina.org/configuration/entry-context" target="_blank" rel="noopener"><code>entry</code></a> 配置手动地分离代码</li>
<li>防止重复：使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a> 去重和分离 chunk</li>
<li>动态导入：通过模块中的内联函数调用来分离代码<br><a name="fc6412ce"></a><h3 id="入口起点-entry-points"><a href="#入口起点-entry-points" class="headerlink" title="入口起点(entry points)"></a>入口起点(entry points)</h3>这是迄今为止最简单、最直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患<br>src/index.js<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  _.join([<span class="string">'index'</span>, <span class="string">'module'</span>, <span class="string">'loaded!'</span>], <span class="string">' '</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>src/another.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  _.join([<span class="string">'Another'</span>, <span class="string">'module'</span>, <span class="string">'loaded!'</span>], <span class="string">' '</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>webpack.config.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    another: <span class="string">'./src/another.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          title: <span class="string">'demo-07-代码分离'</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构建结果<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1554556181316-89bfcb99-e3ce-4ae5-8064-7dde8c369e70.jpeg#align=left&amp;display=inline&amp;height=171&amp;name=20190406210825.jpg&amp;originHeight=440&amp;originWidth=1288&amp;size=115519&amp;status=done&amp;width=500" alt="20190406210825.jpg"><br>正如前面提到的，这种方式存在一些隐患</p>
<ul>
<li>如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中</li>
<li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来</li>
</ul>
<p>这两点中的第一点，对我们的示例来说毫无疑问是个严重问题，因为我们在 <code>./src/index.js</code> 中也引入过 <code>lodash</code>，这样就造成在两个 bundle 中重复引用。我们可以通过使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a> 插件来移除重复模块<br><a name="4c0a6d59"></a></p>
<h3 id="防止重复-prevent-duplication"><a href="#防止重复-prevent-duplication" class="headerlink" title="防止重复(prevent duplication)"></a>防止重复(prevent duplication)</h3><p><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a> 插件可以将公共的依赖模块提取到已有的 entry chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将前面示例中重复的 <code>lodash</code> 模块去除<br><code>CommonsChunkPlugin</code>_ 已经从 webpack v4（代号 legato）中移除。想要了解最新版本是如何处理 chunk，请查看 _<a href="https://webpack.docschina.org/plugins/split-chunks-plugin/" target="_blank" rel="noopener"><code>SplitChunksPlugin</code></a><br>webpack.config.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    another: <span class="string">'./src/another.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          title: <span class="string">'demo-07-代码分离'</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#optimization-splitchunks" target="_blank" rel="noopener"><code>optimization.splitChunks</code></a> 配置选项，现在可以看到已经从 <code>index.bundle.js</code> 和 <code>another.bundle.js</code> 中删除了重复的依赖项。需要注意的是，此插件将 <code>lodash</code> 这个沉重负担从主 bundle 中移除，然后分离到一个单独的 chunk 中。执行 <code>npm run build</code> 查看效果<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1554556361908-c3edbb70-f545-4e8d-98f5-ec6b566993ac.jpeg#align=left&amp;display=inline&amp;height=199&amp;name=20190406210851.jpg&amp;originHeight=512&amp;originWidth=1288&amp;size=154273&amp;status=done&amp;width=500" alt="20190406210851.jpg"><br><br>以下是由社区提供，一些对于代码分离很有帮助的 plugin 和 loader</p>
<ul>
<li><a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin" target="_blank" rel="noopener"><code>mini-css-extract-plugin</code></a>：用于将 CSS 从主应用程序中分离</li>
<li><a href="https://webpack.docschina.org/loaders/bundle-loader" target="_blank" rel="noopener"><code>bundle-loader</code></a>：用于分离代码和延迟加载生成的 bundle</li>
<li><a href="https://github.com/gaearon/promise-loader" target="_blank" rel="noopener"><code>promise-loader</code></a>：类似于 <code>bundle-loader</code> ，但是使用了 promise API</li>
</ul>
<p>以上源码点击<a href="https://github.com/Lucy20209060/webpack-test/tree/master/demo-07" target="_blank" rel="noopener">查看</a><br><a name="05411f79"></a></p>
<h3 id="动态导入-dynamic-imports"><a href="#动态导入-dynamic-imports" class="headerlink" title="动态导入(dynamic imports)"></a>动态导入(dynamic imports)</h3><p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。第一种，也是推荐选择的方式是，使用符合 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">ECMAScript 提案</a> 的 <a href="https://webpack.docschina.org/api/module-methods#import-" target="_blank" rel="noopener"><code>import()</code> 语法</a> 来实现动态导入。第二种，则是 webpack 的遗留功能，使用 webpack 特定的 <a href="https://webpack.docschina.org/api/module-methods#require-ensure" target="_blank" rel="noopener"><code>require.ensure</code></a>。让我们先尝试使用第一种<br>webpack.config.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          title: <span class="string">'demo-08-动态导入'</span></span><br><span class="line">      &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里使用了 <code>chunkFilename</code>，它决定 non-entry chunk(非入口 chunk) 的名称。关于 <code>chunkFilename</code>更多信息，请查看 <a href="https://webpack.docschina.org/configuration/output/#output-chunkfilename" target="_blank" rel="noopener">输出</a> 文档<br>现在不再使用 statically import(静态导入) <code>lodash</code>，而是通过 dynamic import(动态导入) 来分离出一个 chunk<br>src/index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: _ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="string">'An error occurred while loading the component'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getComponent().then(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(component);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里我们需要使用 <code>default</code> 的原因是，从 webpack v4 开始，在 import CommonJS 模块时，不会再将导入模块解析为 <code>module.exports</code> 的值，而是为 CommonJS 模块创建一个 artificial namespace object(人工命名空间对象)，关于其背后原因的更多信息，请阅读 <a href="https://medium.com/webpack/webpack-4-import-and-commonjs-d619d626b655" target="_blank" rel="noopener">webpack 4: import() 和 CommonJs</a>。<br>注意，在注释中我们提供了 <code>webpackChunkName</code>。这样会将拆分出来的 bundle 命名为 <code>lodash.bundle.js</code>，而不是 <code>[id].bundle.js</code>。想了解更多关于 <code>webpackChunkName</code> 和其他可用选项，请查看 <a href="https://webpack.docschina.org/api/module-methods/#import-" target="_blank" rel="noopener"><code>import()</code></a> 文档。让我们执行 webpack，看到 <code>lodash</code> 分离出一个单独的 bundle<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/115449/1554557995061-a0a6ef79-3bf7-48d3-b583-2283474daf90.jpeg#align=left&amp;display=inline&amp;height=146&amp;name=20190406213904.jpg&amp;originHeight=378&amp;originWidth=1296&amp;size=97341&amp;status=done&amp;width=501" alt="20190406213904.jpg"><br>由于 <code>import()</code> 会返回一个 promise，因此它可以和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener"><code>async</code> 函数</a>一起使用。但是，需要使用像 Babel 这样的预处理器和 <a href="https://babel.docschina.org/docs/en/babel-plugin-syntax-dynamic-import/#installation" target="_blank" rel="noopener">Syntax Dynamic Import Babel Plugin</a>。下面是如何通过 async 函数简化代码<br>src/index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>);</span><br><span class="line">  element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line">getComponent().then(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(component);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><a name="f6a36429"></a></p>
<h3 id="预取-预加载模块-prefetch-preload-module"><a href="#预取-预加载模块-prefetch-preload-module" class="headerlink" title="预取/预加载模块(prefetch/preload module)"></a>预取/预加载模块(prefetch/preload module)</h3><p>webpack v4.6.0+ 添加了预取和预加载的支持<br>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器</p>
<ul>
<li>prefetch(预取)：将来某些导航下可能需要的资源</li>
<li>preload(预加载)：当前导航下可能需要资源</li>
</ul>
<p>下面这个 prefetch 的简单示例中，有一个 <code>HomePage</code> 组件，其内部渲染一个 <code>LoginButton</code> 组件，然后在点击后按需加载 <code>LoginModal</code> 组件<br>LoginButton.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">'LoginModal'</span>);</span><br></pre></td></tr></table></figure>
<p>这会生成 <code>&lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt;</code> 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件<br>与 prefetch 指令相比，preload 指令有许多不同之处</p>
<ul>
<li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载</li>
<li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载</li>
<li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻</li>
<li>浏览器支持程度不同</li>
</ul>
<p>下面这个简单的 preload 示例中，有一个 <code>Component</code>，依赖于一个较大的 library，所以应该将其分离到一个独立的 chunk 中<br>我们假想这里的图表组件 <code>ChartComponent</code> 组件需要依赖体积巨大的 <code>ChartingLibrary</code> 库。它会在渲染时显示一个 <code>LoadingIndicator(加载进度条)</code> 组件，然后立即按需导入 <code>ChartingLibrary</code><br>ChartComponent.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPreload: true */</span> <span class="string">'ChartingLibrary'</span>);</span><br></pre></td></tr></table></figure></p>
<p>在页面中使用 <code>ChartComponent</code> 时，在请求 ChartComponent.js 的同时，还会通过 <code>&lt;link rel=&quot;preload&quot;&gt;</code>请求 charting-library-chunk。假定 page-chunk 体积很小，很快就被加载好，页面此时就会显示 <code>LoadingIndicator(加载进度条)</code> ，等到 <code>charting-library-chunk</code> 请求完成，LoadingIndicator 组件才消失。启动仅需要很少的加载时间，因为只进行单次往返，而不是两次往返。尤其是在高延迟环境下。<br>不正确地使用 webpackPreload 会有损性能，请谨慎使用<br><a name="206c76a3"></a></p>
<h3 id="bundle-分析-bundle-analysis"><a href="#bundle-分析-bundle-analysis" class="headerlink" title="bundle 分析(bundle analysis) "></a>bundle 分析(bundle analysis) <a href="https://webpack.docschina.org/guides/code-splitting/#bundle-%E5%88%86%E6%9E%90-bundle-analysis-" target="_blank" rel="noopener"></a></h3><p>如果我们以分离代码作为开始，那么就应该以检查模块的输出结果作为结束，对其进行分析是很有用处的。<a href="https://github.com/webpack/analyse" target="_blank" rel="noopener">官方提供分析工具</a> 是一个好的初始选择。下面是一些可选择的社区支持(community-supported)工具</p>
<ul>
<li><a href="https://alexkuz.github.io/webpack-chart/" target="_blank" rel="noopener">webpack-chart</a>：webpack stats 可交互饼图</li>
<li><a href="https://chrisbateman.github.io/webpack-visualizer/" target="_blank" rel="noopener">webpack-visualizer</a>：可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的</li>
<li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a>：一个 plugin 和 CLI 工具，它将 bundle 内容展示为便捷的、交互式、可缩放的树状图形式</li>
<li><a href="https://webpack.jakoblind.no/optimize" target="_blank" rel="noopener">webpack bundle optimize helper</a>：此工具会分析你的 bundle，并为你提供可操作的改进措施建议，以减少 bundle 体积大小</li>
</ul>
<p>以上源码点击<a href="https://github.com/Lucy20209060/webpack-test/tree/master/demo-08" target="_blank" rel="noopener">查看</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-04-06</span><i class="fa fa-tag"></i><a class="tag" href="/tags/webpack/" title="webpack">webpack </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/04/07/webpack—懒加载/" title="webpack—懒加载">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/04/04/webpack—treeShaking/" title="webpack—tree shaking">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>