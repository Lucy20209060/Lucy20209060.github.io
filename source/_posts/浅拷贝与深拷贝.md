---
title: 浅拷贝与深拷贝
date: 2018-11-09 22:49:00
tags: ['js', '浅拷贝', '深拷贝']
summary:
---
<span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">JavaScript有两种数据类型，基础数据类型和引用数据类型。基础数据类型都是按值访问的，我们可以直接操作保存在变量中的实际的值。而引用类型如Array，我们不能直接操作对象的堆内存空间。引用类型的值都是按引用访问的，即保存在变量对象中的一个地址，该地址与堆内存的实际值相关联</span></span>

### <span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">浅拷贝（shallow copy）</span></span>
<span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存 </span></span>


### <span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">深拷贝（deep copy）</span></span>
<span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">复制并创建一模一样的对象，不共享内存，修改新对象，旧对象保持不变</span></span>
```javascript
var a = 1;
var b= a;
a = 2;
console.log(a, b) // 2 1

// 浅拷贝
var obj1 = { name: 'lucy', age: 20}
var obj2 = obj1;
obj1.age = 25;
console.log(obj1) // {name: 'lucy', age: 25}
console.log(obj2) // {name: 'lucy', age: 25}

//深拷贝
var obj1 = { a: 1, b: 2, c: 3 };
var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };
obj2.b = 4;
console.log(obj1); // { a: 1, b: 2, c: 3 }
console.log(obj2); // { a: 1, b: 4, c: 3 }
```

### 深拷贝的实现
#### 1. Object.assign()
```javascript
var obj1 = { a: 1, b: 2, c: 3 };
var obj2 = Object.assign({},obj1);
```

`Object.assign()`<span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">是一种可以对</span></span><span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)"><code>非嵌套对象</code></span></span><span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">进行深拷贝的方法，如果对象中出现嵌套情况，那么其对被嵌套对象的行为就成了普通的浅拷贝!!</span></span>

#### 2. 借助JSON.parse() 和 JSON.stringify()
```javascript
var obj1 = { a: 1, b: 2, c: 3 };
var obj2 = JSON.parse(JSON.stringify(obj1));
```

<span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">但这种方法的缺陷是会破坏原型链，并且无法拷贝属性值为function的属性</span></span>

#### 3. 递归
<span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">采用递归的方法去复制拷贝对象</span></span>
```javascript
var json1={
  "name":"lucy",
  "age":20,
  "arr1":[1,2,3,4,5],
  "arr3":[
    {"name":"tom"},
    {"job":"web"}
  ],
  fun: function(){}
};

function copy(obj1,obj2){
  var obj2=obj2||{};
  for(var name in obj1){
    console.log(name, typeof obj1[name])
    if(typeof obj1[name] === "object"){ 
      obj2[name] = obj1[name].constructor === Array ? [] : {};
      copy(obj1[name],obj2[name]);
    }else{
      obj2[name] = obj1[name];
    }
  }
  return obj2;
}

var json2=copy(json1);
```