---
title: 柯里化与反柯里化
date: 2019-03-20 15:30:28
tags: ['柯里化', '反柯里化']
summary:
---
<a name="c28ab5f2"></a>
### 柯里化
柯里化又称部分求值，就是不会立刻求值，而是到了需要的时候再去求值，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果<br />把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数
<a name="55b79f93"></a>
#### 求和函数
```javascript
var adder = function () {
    var _args = [];
    return function () {
        if (arguments.length === 0) {
            return _args.reduce(function (a, b) {
                return a + b;
            });
        }
        // apply的第一个参数是用来替换的操作对象，第二个参数是要变成push参数的数组
        [].push.apply(_args, [].slice.call(arguments));
        return arguments.callee;
    }
};
var sum = adder();
// 一次调用可输入一个或者多个参数，并且支持链式调用 
var a = sum(1)(2,3)(4)()
console.log(a) // 10
```
`adder`是柯里化了的函数，它返回一个新的函数，新的函数可分批次接受新的参数，延迟到最后一次计算
<a name="90743082"></a>
#### 通用的柯里化函数
```javascript
var currying = function (fn) {
    var _args = [];
    return function () {
        if (arguments.length === 0) {
            return fn.apply(this, _args);
        }
        Array.prototype.push.apply(_args, [].slice.call(arguments));
        return arguments.callee;
    }
};

var multi=function () {
    var total = 0;
    for (var i = 0, c; c = arguments[i++];) {
        total += c;
    }
    return total;
};
var sum = currying(multi);
  
sum(1,2)(3);
sum(4);
console.log(sum()); // 10
```

<a name="7e703669"></a>
### 反柯里化
反柯里化的作用在与扩大函数的适用性，使本来作为特定对象所拥有的功能的函数可以被任意对象所用<br />有以下轻提示类。现在想要单独使用其`show`方法，输出新对象`obj`中的内容
```javascript
// 轻提示
function Toast(option){
  this.prompt = '';
}
Toast.prototype = {
  constructor: Toast,
  // 输出提示
  show: function(){
    console.log(this.prompt);
  }
};
var obj = {
    prompt: '新对象'
};
function unCurrying(fn){
    return function(){
        var args = [].slice.call(arguments);
        var that = args.shift(); // obj
        return fn.apply(that, args);
    }
}
var objShow = unCurrying(Toast.prototype.show);
objShow(obj); // 新对象
```
`Toast.prototype.show`方法，本来是`Toast`类的私有方法。跟新对象`obj`没有任何关系，经过反柯里化后，却可以为`obj`对象所用 <br />内部将`Toast.prototype.show`的上下文重新定义为`obj`。也就是用`apply`改变了`this`指向。 <br />而实现这一步骤的过程，就需要增加反柯里化后的`objShow`方法参数
<a name="a3d74e7c"></a>
#### 另一种反柯里化的实现
```javascript
// 轻提示
function Toast(option){
  this.prompt = '';
}
Toast.prototype = {
  constructor: Toast,
  // 输出提示
  show: function(){
    console.log(this.prompt);
  }
};
var obj = {
    prompt: '新对象'
};
Function.prototype.unCurrying = function(){
    var self = this;
    return function(){
        return Function.prototype.call.apply(self, arguments);
    }
}

// 使用
var objShow = Toast.prototype.show.unCurrying();
objShow(obj);
```
理解 `Function.prototype.call.apply(self, arguments)`<br />可以分拆为两步：<br />1） **`Function.prototype.call.apply(...)`的解析**<br />可以看成是`callFunction.apply(...)`。这样就清晰很多 <br />`callFunction`的`this`指针，被`apply`修改为`self`。 <br />然后执行`callFunction` -> `callFunction(arguments)`<br />2） **`callFunction(arguments)`的解析**<br />`call`方法，第一个参数，是用来指定`this`的。所以`callFunction(arguments)` -> `callFunction(arguments[0], arguments[1-n])`。 <br />由此可以得出，反柯里化后，第一个参数，是用来指定`this`指向的。<br />3）**为什么要用apply(self, arguments)** <br />如果使用`apply(null, arguments)`，因为`null`对象没有`call`方法，会报错