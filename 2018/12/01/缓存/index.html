<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>缓存 · 长剑腥腥挂壁</title><meta name="description" content="缓存缓存就是数据交换的缓冲区（称作Cache），这个概念最初是来自于内存和CPU。当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行
浏览器缓存强缓存浏览器第一次请求数据时，服务器会将"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title=""><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>缓存</a></h3></div><div class="post-content"><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">缓存就是数据交换的缓冲区（称作Cache），这个概念最初是来自于内存和CPU。当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行</span></span></p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">浏览器缓存</span></span></h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>浏览器第一次请求数据时，服务器会将文件的过期时间和文件一起返回给客户端，客户端将二者备份至缓存中。再次请求数据时，客户端将根据文件的过期时间去判断，文件是否过期。文件未过期，则直接使用缓存中文件，文件过期了，则重新从服务器上获取。</p>
<p><code>expires</code>是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，即文件过期时间，由服务器返回。第二次请求时，将和本地时间比对，如果文件未过期则直接使用本地缓存，返回状态码200(from memory cache)或200(from disk cache)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/115449/1543545757681-41588cdb-cde0-415b-88b8-0b6d0741da93.png" alt="20181130104227.png | center | 539x479"></p>
<p><code>cache-control</code>第一次请求服务器时，响应头会返回一个 max-age，是文件多少时间后过期。第二次请求，客户端会校验文件是否过期，如果文件未过期则直接使用本地缓存，返回状态码200(from memory cache)或200(from disk cache)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/115449/1543546063708-4ce187d9-49f2-4396-8378-40d472b25e2e.png" alt="20181130104732.png | center | 535x481"></p>
<p>cache-control: no-cache 必须先与代理服务器确认是否更改，然后在在决定使用缓存还是请求，类似于协商缓存（304）<br>cache-control: no-store 真正的不缓存数据到本地<br>cache-control: public 可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器<br>cache-control: private 只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存<br>cache-control: must-revalidate 如果缓存内容失效，请求必须发送服务器进行验证<br>cache-control: max-age=s 缓存内容在s秒后失效，仅HTTP1.1可用</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存中。 再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据</p>
<h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h4><p>通过文件的最后修改时间判断该不该读取缓存，服务端设置响应头Last-Modified,客户端把上次服务端响应头中的Last-modified值通过if-modified-since 传递给服务端 ， 服务端通过比较当前文件的修改时间和上次修改时间(上次传给客户端的值),如果相等那么说明文件修改时间没变也就是没变化，如果缓存文件未过期则返回304状态码，客户端使用缓存文件。如果缓存过期则返回新文件，状态码为200<br>Last-Modified的一次请求时，服务器返回的响应头里面包含缓存标识Last-Modified<br>Last-Modified的第二次请求时，请求头包含If-Modified-Since,服务器获取到该缓存标识后，用该标识和文件进行比对</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/115449/1543547799880-95da67db-885d-45cc-9914-fbdcb0a7d795.png" alt="20181130111526.png | center | 479x597"></p>
<h4 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag / If-None-Match"></a>Etag / If-None-Match</h4><p>通过文件的内容来判断该不该读取缓存，服务端通过把文件内容读取出来，通过md5进行base64加密得出hash值，把这个值设置响应头Etag，客户端下一次请求通过if-none-match带过来，服务端再比对当前文件内容加密得出的hash值和上次是否一样，如果一样说明文件内容没有发生改变，这种方式是最准确的方式，但是也是最耗性能<br>Etag的第二次请求时，请求头包含If-None-Match,服务器获取到该缓存标识后，用该标识和文件进行比对。如果缓存文件未过期则返回304状态码，客户端使用缓存问题。如果缓存过期则返回新文件，状态码为200</p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/png/115449/1543548195892-8b5b157b-5a2f-4cd8-8491-3f6be513ad89.png" alt="20181130112106.png | center | 482x589"></p>
<h3 id="CDN代理服务器缓存"><a href="#CDN代理服务器缓存" class="headerlink" title="CDN代理服务器缓存"></a>CDN代理服务器缓存</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。（CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现）<br>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。<br>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。用户向CDN的全局负载均衡设备发起内容URL访问请求。CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备（边缘节点），告诉用户向这台设备发起请求。均衡设备把服务器的IP地址返回给用户。<br>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务（多级缓存）器请求内容，直至追溯到网站的源服务器将内容拉到本地（回源）</p>
<h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><p>页面缓存，这种缓存技术一般用于不会经常变动信息，并且访问次数较多的页面，这样就不用每次都动态加载。<br>模板缓存，有些语言程序运行时动态对程序进行编译，为了避免每次请求都进行编译，则会缓存编译后的一个模板文件。<br>数据缓存，页面数据来自DB时，每次DB操作是需要消耗时间和资源的。将高频操作的数据放入到内存中，避免频繁的操作数据库</p>
<h3 id="各缓存头的优先级"><a href="#各缓存头的优先级" class="headerlink" title="各缓存头的优先级"></a>各缓存头的优先级</h3><ol>
<li>强缓存和协商缓存同时存在，如果强缓存还在生效期则强制缓存覆盖协商缓存，协商缓存不生效；如果强缓存不在有效期，协商缓存生效。即：强缓存优先级 &gt; 协商缓存优先级</li>
<li>强缓存expires和cache-control同时存在时，则cache-control会覆盖expires，expires无论有没有过期，都无效。 即：cache-control优先级 &gt; expires优先级</li>
<li>协商缓存Etag和Last-Modified同时存在时，则Etag会覆盖Last-Modified，Last-Modified不会生效。即：ETag优先级 &gt; Last-Modified优先级</li>
<li>当然还有一种缓存pragma，和cache-control类似，前者是http1.0内容后者是http1.1内容，并且pragma优先级 &gt; cache-control优先级，不过前者目前基本不使用。</li>
</ol>
<p>由于大部分前端项目中css和js在打包时加了md5值，建议直接使用强缓存，并且expires和cache-control同时使用，建议设置时长为7天较为妥当。图片文件由于没有加md5值，建议采用协商缓存，html文件也建议采用协商缓存</p>
<p>ps: 当我们不设置cache-control，只设置协商缓存，在不同浏览器下会有不同的表现。chrome会直接从本地缓存获取，其他会请求服务器返回304。这时候有两种方式让他们的响应一致。<br>1、设置cache-control: public, max-age=0;记住，这里的public是关键。因为默认值是private，表示其他代理都不要缓存，只有服务器缓存，而max-age又为0，所以每次都会发起200的请求。设置public的意思就是允许其他各级代理缓存资源，因此如果资源没改变会返回304。<br>2、直接设置max-age=1000。即是一秒之后内容过期，目的是触发浏览器缓存。也能达到想要304的效果</p>
<h3 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h3><ul>
<li>提高响应速度，减少响应延迟</li>
<li>减少资源消耗（服务器、带宽）</li>
</ul>
<h3 id="缓存可能导致的问题"><a href="#缓存可能导致的问题" class="headerlink" title="缓存可能导致的问题"></a>缓存可能导致的问题</h3><ul>
<li>缓存雪崩，是指缓存使用不合理时，某一时间缓存失效，大量请求会直接到达向服务器，服务器无法承载大量请求，就导致服务器崩溃</li>
<li>缓存更新不及时，是指缓存使用不合理时，服务器文件更新，用户获取到的还是旧的错误的缓存文件</li>
</ul>
<h3 id="合理使用缓存"><a href="#合理使用缓存" class="headerlink" title="合理使用缓存"></a>合理使用缓存</h3><ol>
<li>分离变化的部分,经常变化的业务逻辑和基础工具库抽离</li>
<li>对基础工具库可以设置长缓存Cache-Control: max-age=31536000</li>
<li>对经常变化的因为逻辑可以使用短缓存时间+must-revalidate 或者使用协商缓存</li>
<li>使用文件戳控制缓存</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-12-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/缓存/" title="缓存">缓存 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/12/03/ReactHooks/" title="React Hooks">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/11/30/js的变量提升和函数提升/" title="js的变量提升和函数提升">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>