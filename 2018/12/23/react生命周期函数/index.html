<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Lucy"><title>react生命周期函数 · 长剑腥腥挂壁</title><meta name="description" content="生命周期函数是指在某一个周期自动执行的函数

constructor() 构造函数不是周期函数执行时间：组件被加载前最先调用，并且仅调用一次作用：定义状态机变量注意：第一个语句必须是super（props）
componentWillMount()执行时间：组件初始渲染（render()被调用前）前"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/logo-2.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo-2.png" style="width:127px;"><h3 title=""><a href="/">长剑腥腥挂壁</a></h3></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo-2.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>react生命周期函数</a></h3></div><div class="post-content"><p><span data-type="color" style="color:rgb(79, 79, 79)"><span data-type="background" style="background-color:rgb(255, 255, 255)">生命周期函数是指在某一个周期自动执行的函数</span></span></p>
<p><img src="https://cdn.nlark.com/yuque/0/2018/jpeg/115449/1545496395236-fda34876-b4b2-469d-a337-e9227e7561cc.jpeg" alt="00_32_25__12_23_2018.jpg | center | 747x315"></p>
<h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor() 构造函数"></a>constructor() 构造函数</h3><p>不是周期函数<br>执行时间：组件被加载前最先调用，并且仅调用一次<br>作用：定义状态机变量<br>注意：第一个语句必须是super（props）</p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p>执行时间：组件初始渲染（render()被调用前）前调用，并且仅调用一次<br>作用：如果在这个函数中调用setState改变某些状态机，react会等待setState完成后再渲染组件<br>注意：子组件也有componentWillMount函数，在父组件的该函数调用后再被调用</p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p>执行时间：componentWillMount之后，componentDidMount之前<br>作用：渲染挂载组件<br>触发条件：（1）初始化加载页面（2）状态机改变setState ( 3 ) 接收到新的props（父组件更新）<br>注意：组件所必不可少的核心函数；不能在该函数中修改状态机state</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>执行时间：render之后被调用，并且仅调用一次<br>作用：渲染挂载组件；可以使用refs<br>注意：子组件也有该函数，在父组件的该函数调用前被调用；如果在该函数中修改某些状态机state，会重新渲染render组件，所以有些组件为减少渲染次数，可以将某些修改状态机的操作放在componentWillMount函数中；如果需要再程序启动显示初始化页面后从服务端获取数据，可以将网络请求代码放在该函数中</p>
<h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h3><p>执行时间：组件渲染后，当组件接收到新的props时被调用；这个函数接收一个object参数（新的props）；props是父组件传递给子组件的。父组件发生render的时候子组件就会调用<br>作用：渲染挂载组件；可以使用refs<br>注意：react初次渲染时，该函数并不会被触发，因此有时该函数需要和componentWillMount或componentDidMount组合使用;使用该函数一定要加nextProps参数</p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><p>执行时间：组件挂载后（即执行完render），接收到新的state或props时被调用，即每次执行setState都会执行该函数，来判断是否重新render组件，默认返回true；接收两个参数：第一个是心的props，第二个是新的state。<br>作用：如果有些变化不需要重新render组件，可以在该函数中阻拦<br>注意：该方法在初始化渲染的时候不会调用，在使用 forceUpdate 方法的时候也不会</p>
<h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate()"></a>componentWillUpdate()</h3><p>执行时间：在接收到新的props 或者 state，重新渲染之前立刻调用，在初始化渲染的时候该方法不会被调用<br>作用：为即将发生的重新渲染做一些准备工作<br>注意：不能再该函数中通过this.setstate再次改变状态机，如果需要，则在componentWillReceiveProps函数中改变</p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><p>执行时间：重新渲染后调用，在初始化渲染的时候该方法不会被调用<br>作用：使用该方法可以在组件更新之后操作DOM 元素</p>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><p>执行时间：组件被卸载前调用<br>作用：在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素</p>
<p><strong>注意</strong>：React中的render()也是生命周期函数，而constructor()并不是生命周期函数<br>生命周期函数是针对组件来说的，并非只有父组件才有生命周期函数，是所有组件都有生命周期函数<br>除了render()函数，其他的所有生命周期函数都可以不写，也不会报错，但是如果缺少render()函数程序就会报错，因为所有的生命周期函数除了render()函数都是继承自React中内置的<br>AJAX请求一般放在componentDidMount()里面</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-12-23</span><i class="fa fa-tag"></i><a class="tag" href="/tags/react/" title="react">react </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/12/24/http状态码/" title="http状态码">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/12/23/Proxy对象/" title="Proxy对象">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>